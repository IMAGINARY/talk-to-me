<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Talk to Me</title>
    <link rel="stylesheet" type="text/css" href="../../node_modules/@fortawesome/fontawesome-free/css/all.css">
    <link rel="stylesheet" type="text/css" href="../../node_modules/bootstrap/dist/css/bootstrap-reboot.min.css">
    <link rel="stylesheet" type="text/css" href="../../node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/circular-btn.css">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <script>
        const assert = require('assert');
        const fs = require('fs').promises;
        const path = require('path');
        const EventEmitter = require('events');
        const ndarray = require('ndarray');
        const unpack = require('ndarray-unpack');
        const ops = require('ndarray-ops');
        const opsExt = require('../js/common/ndarray-ops-ext.js');
        const colormap = require('colormap');

        const $ = require("jquery");
        const popper = require("popper.js");
        const bootstrap = require('bootstrap');

        const wav2letter = require("../js/common/wav2letter/wav2letter.js");
        const w2lUtils = require('../js/common/wav2letter/util.js');

        const FixedSizeBuffer = require("../js/common/util/FixedSizeBuffer.js");
        const WaveformVisualizer = require("../js/renderer/waveform-visualizer.js");

        Promise.all(['en', 'de'].map(lang => wav2letter.transcribe({waveform: new Float32Array(), lang: lang})))
            .then(() => console.log("Speech recognition models loaded."));

        // maps a value between 0 and 1 to RGB color array
        const heatmap = (() => {
            const palette = colormap({
                colormap: 'hot',
                nshades: 256,
                format: 'rgba',
                alpha: 1
            }).reverse();

            // map (0, 1) range for alpha to (0, 255)
            palette.forEach(c => c[3] = c[3] * 255);

            return value => {
                const constrainedValue = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
                const index = Math.floor(255 * constrainedValue);
                return palette[index];
            };
        })();

        const alphamap = (() => {
            const palette = Array.from({length: 256}, (_, i) => [0, 0, 0, i]);
            return value => {
                const constrainedValue = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
                const index = Math.floor(255 * constrainedValue);
                return palette[index];
            };
        })();

        async function init() {
            const waveformCanvas = document.querySelector('#waveform-viz');
            const waveformCtx = waveformCanvas.getContext("2d");
            const spectrogramCanvas = document.querySelector('#spectrogram-viz');
            const spectrogramCtx = spectrogramCanvas.getContext("2d");
            const transcriptionCanvas = document.querySelector('#transcription-viz');
            const transcriptionCtx = transcriptionCanvas.getContext("2d");

            function setTranscriptionTexts(indices, probabilities, alphabet, numBest) {
                transcriptionCtx.clearRect(0, 0, transcriptionCanvas.width, transcriptionCanvas.height);

                transcriptionCtx.font = "16px monospace";

                const lineHeight = 16;
                const charWidth = transcriptionCanvas.width / indices.shape[0];
                for (let position = 0; position < indices.shape[0]; ++position) {
                    const bestK = indices.pick(position).hi(numBest);
                    const sup = ops.sup(probabilities.pick(position));
                    for (let lineNum = 0; lineNum < bestK.shape[0]; ++lineNum) {
                        const charIndex = bestK.get(lineNum);
                        const char = alphabet[charIndex];
                        const opacity = probabilities.get(position, charIndex) / sup;
                        transcriptionCtx.fillStyle = `rgba(0,0,0,${opacity})`;
                        transcriptionCtx.fillText(char, position * charWidth, lineHeight * (numBest - lineNum));
                        console.log(char, opacity);
                    }
                    console.log("-");
                }
            }

            function addLettersForPredictionExt(predictionExt) {
                const letterActivations = predictionExt.layers[11];
                const decoded = wav2letter.decoder.decodeGreedyAll(letterActivations);
                const letterProbabilities = ndarray(new Float32Array(letterActivations.shape[0] * letterActivations.shape[1]), letterActivations.shape);
                opsExt.sigmoid(letterProbabilities, letterActivations);
                setTranscriptionTexts(decoded, letterProbabilities, predictionExt.letters, 4);
            }

            function drawSpectrogram(logMelSpectrogramData) {
                // TODO: avoid creating a new canvas every time
                const tempCanvas = document.createElement("canvas");
                const tempCtx = tempCanvas.getContext("2d");

                const min = ops.inf(logMelSpectrogramData);
                const max = ops.sup(logMelSpectrogramData);
                const range = Math.max(max - min, Number.EPSILON);

                const imageData = tempCtx.createImageData(logMelSpectrogramData.shape[0], logMelSpectrogramData.shape[1]);
                for (let y = 0; y < imageData.height; ++y) {
                    for (let x = 0; x < imageData.width; ++x) {
                        const value = logMelSpectrogramData.get(x, y);
                        const normalizedValue = (value - min) / range;
                        const color = alphamap(normalizedValue);
                        imageData.data[4 * (y * imageData.width + x) + 0] = color[0];
                        imageData.data[4 * (y * imageData.width + x) + 1] = color[1];
                        imageData.data[4 * (y * imageData.width + x) + 2] = color[2];
                        imageData.data[4 * (y * imageData.width + x) + 3] = color[3];
                    }
                }
                tempCtx.putImageData(imageData, 0, 0);

                spectrogramCtx.imageSmoothingEnabled = false;

                spectrogramCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);

                spectrogramCtx.save();
                const xScale = spectrogramCanvas.width / logMelSpectrogramData.shape[0];
                const yScale = spectrogramCanvas.height / logMelSpectrogramData.shape[1];
                spectrogramCtx.translate(0, spectrogramCanvas.height);
                spectrogramCtx.scale(xScale, -yScale);
                spectrogramCtx.drawImage(tempCanvas, 0, 0);
                spectrogramCtx.restore();
            }

            const lengthInMs = 2000;
            const sampleRate = 16000;
            const context = new AudioContext({sampleRate: sampleRate});
            const audioBuffer = context.createBuffer(1, lengthInMs * sampleRate / 1000, sampleRate);
            const samples = FixedSizeBuffer.wrapArray(audioBuffer.getChannelData(0));

            // Initially fill up the buffer
            samples.push(new Float32Array(samples.maxLength));

            const createFilters = context => {
                const filter = context.createBiquadFilter();
                filter.Q.value = 8.30;
                filter.frequency.value = 355;
                filter.gain.value = 3.0;
                filter.type = 'bandpass';

                const compressor = context.createDynamicsCompressor();
                compressor.threshold.value = -50;
                compressor.knee.value = 40;
                compressor.ratio.value = 12;
                compressor.reduction.value = -20;
                compressor.attack.value = 0;
                compressor.release.value = 0.25;

                filter.connect(compressor);

                return [filter, compressor];
            };

            const micStream = await navigator.mediaDevices.getUserMedia({
                audio: {sampleRate: 16000, noiseSuppression: true, autoGainControl: false},
                video: false
            });

            const source = context.createMediaStreamSource(micStream);
            const gain = context.createGain();
            const processor = context.createScriptProcessor(1024, 1, 1);
            processor.onaudioprocess = e => samples.push(e.inputBuffer.getChannelData(0));
            const filters = createFilters(context);

            window.context = context;
            window.micStream = micStream;

            const useFilters = false
            if (useFilters) {
                source.connect(gain);
                gain.connect(filters[0]);
                filters[filters.length - 1].connect(processor);
                filters[filters.length - 1].connect(context.destination);
            } else {
                source.connect(gain);
                gain.connect(context.destination);
                gain.connect(processor);
            }

            samples.on('full', async data => {
                await stopRecording();

                window.waveform = data;
                window.predictionExt = await wav2letter.predictExt({waveform: data, lang: language});
                addLettersForPredictionExt(window.predictionExt);
                drawSpectrogram(window.predictionExt.logMelSpectrogram);
            });

            async function startRecording() {
                document.getElementById("record-button").style.color = 'red';
                reset();
                samples.clear();
                processor.connect(context.destination);
                await unmuteRecording();
            }

            async function stopRecording() {
                document.getElementById("record-button").style.color = "inherit";
                await muteRecording();
                processor.disconnect();
            }

            async function muteRecording() {
                gain.gain.value = 0.0;
            }

            async function unmuteRecording() {
                gain.gain.value = 1.0;
            }

            async function playRecording() {
                const bufferSource = context.createBufferSource();
                bufferSource.buffer = audioBuffer;
                bufferSource.connect(context.destination);
                const playbackEnded = new Promise(resolve => {
                    const listener = () => {
                        bufferSource.removeEventListener("ended", listener);
                        bufferSource.disconnect();
                        resolve();
                    };
                    bufferSource.addEventListener("ended", listener);
                });
                bufferSource.start();
                await playbackEnded;
            }

            await stopRecording();

            const waveformVisualizer = new WaveformVisualizer(waveformCanvas, samples);

            function reset() {
                samples.clear();
                spectrogramCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
                transcriptionCtx.clearRect(0, 0, transcriptionCanvas.width, transcriptionCanvas.height);
            }

            let language = "en";
            $("#language-selector > a").on('click', e => {
                const language = e.currentTarget.getAttribute("data-lang");
                state.setLanguage(language);
            });

            function setLanguage(lang) {
                language = lang;
                reset();
            }

            return {
                startRecording: startRecording,
                stopRecording: stopRecording,
                muteRecording: muteRecording,
                playRecording: playRecording,
                setLanguage: setLanguage,
            };
        }
    </script>
</head>
<body>
<div id="main">
    <div id="waveform">
        <canvas id="transcription-viz" width="1024" height="72"></canvas>
        <br/>
        <canvas id="spectrogram-viz" width="1024" height="256"></canvas>
        <br/>
        <canvas id="waveform-viz" width="1024" height="256"></canvas>
    </div>
    <br>
    <br>
    <div id="audio-controls">
        <button id="record-button" type="button" class="btn btn-secondary btn-circle btn-xl"
                onmousedown="state.startRecording();">
            <i class="fas fa-microphone fa-3x">
            </i>
        </button>
        <button id="play-button" type="button" class="btn btn-secondary btn-circle btn-xl"
                onmousedown="state.playRecording();">
            <i class="fas fa-play fa-2x"
               style="transform: translateX(0.225ex);">
            </i>
        </button>
    </div>
    <div id="language-controls">
        <div class="btn-group dropright">
            <button type="button" class="btn btn-secondary btn-lg dropdown-toggle" data-toggle="dropdown"
                    aria-haspopup="true" aria-expanded="false">
                <i class="fas fa-language fa-lg"></i>
            </button>
            <div id="language-selector" class="dropdown-menu">
                <a data-lang="de" class="dropdown-item" href="#">Deutsch</a>
                <a data-lang="en" class="dropdown-item" href="#">English</a>
            </div>
        </div>
    </div>
</div>
<script>
    let state;
    init().then(s => state = s);
</script>
</body>
</html>
